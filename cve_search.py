import argparse
import platform
import importlib
import pkgutil
import re
import requests
from urllib.error import HTTPError
import csv

parser = argparse.ArgumentParser(description='Generate a report of known software vulnerabilities on this system.')
parser.add_argument('-p', '--package', nargs=2, help='Queries the database for the specified package/version pair.')
parser.add_argument('-ap', '--allPackages', action='store_true', help='Queries the database for all packages installed on the system the script is running on.')
parser.add_argument('-f', '--file', help='Queries the database for a series of package/version pairs supplied in the specified file. The format for said file must be <package> <version> with each separated by a new line.')
parser.add_argument('-r', '--remote', help='Sets the database url for queries to the specified url. This flag must be paired with another one to perform a query.')
parser.add_argument('-v', '--verbose', action='store_true', help='Will expand the reporting done by breaking down the package version into parts to query for. This will potentially list more vulnerabilities due to a much broader search, but the results might not be applicable to the actual installed software.')

modules = {
    importlib.import_module(f'plugins.{name}')
    for finder, name, ispkg
    in pkgutil.iter_modules(['plugins'])
}

def main():
    parse_args()

    software_list = []
    if package:
        software_list.append(f'{package[0]} {package[1]} ')
    
    if file_path:
        software_list.extend(get_software_from_file(file_path))

    if all_packages:
        determine_os()
        software_list.extend(get_all_software_from_sys())
    
    software_dict = parse_package_version_pairs(software_list)
    #print(software_dict)
    query_results = query_database(software_dict)
    generate_report(query_results)


def determine_os():
    global os_module

    def match(supported_os_str: str, os_info: str) -> bool:
        if supported_os_str == os_info:
            return True
        
        supported_os_split = supported_os_str.split(':')
        os_info_split = os_info.split(':')
        for i in range(0, len(supported_os_split)):
            if supported_os_split[i] != '*' or supported_os_split[i] != os_info_split[i]:
                return False


        return True

    os_type = platform.system()

    if len(os_type) == 0:
        print('Error: Could not determine the system OS!')
        exit(1)

    if os_type == 'Linux':
        import distro
        os_distro = distro.name()
        if len(os_distro) == 0:
            print('Error: Could not determine Linux distro!')
            exit(1)
        os_type += f':{os_distro}'
    else:
        os_type += ':*'

    for module in modules:
        for supported_os_str in module.get_supported_os():
            if match(supported_os_str, os_type):
                os_module = module
                print('Sucessfully matched OS with supported module')
                return
    
    print(f'Error: No module found for this OS! Supplied OS: {os_type}')
    print(platform.system())
    exit(1)



def parse_args():
    global all_packages, package, verbose, file_path, remote_url

    args = parser.parse_args()
    all_packages = args.allPackages
    package = tuple(args.package) if args.package else None
    file_path = args.file
    remote_url = args.remote
    verbose = args.verbose

    if remote_url and ('<package>' not in remote_url or '<version>' not in remote_url):
        print('Remote url string is not formatted correctly!')
        exit(1)

def get_software_from_file(path: str) -> list:
    software = []
    with open(path, 'r') as software_file:
        software = software_file.readlines()
    return software

def get_all_software_from_sys():
    return os_module.get_software_list()

def break_package_string(string: str) -> list:
    if not string:
        return []
    
    string_list = []
    built_string = ''

    search_list = re.findall(r'[_+\-~]?(?:[0-9\.:]+|[a-zA-Z]+)', string)
    for item in search_list:
        built_string += item
        string_list.append(built_string)

    return string_list

def parse_package_version_pairs(software_list: list) -> dict:
    software_keys = []
    software_versions = []
    software_dict = {}

    for line in software_list:
        if len(line) == 0 or re.match(r'[ \n]+', line):
            continue

        softwarePattern = re.search(r'^[a-zA-Z\-\.0-9+_~]+[/ ]', line)
        versionPattern = re.search(r' \d+[^\s]*\s', line)

        if not softwarePattern:
            print(f'Error: Error parsing software package! Skipping: {line}')
            continue
        if not versionPattern:
            print(f'Error: Error parsing software version! Skipping: {line}')
            continue

        software_keys = break_package_string(softwarePattern.group()[:-1])
        version = versionPattern.group().strip()
        software_versions = break_package_string(version) if verbose else [version]
        software_keys.reverse()
        software_versions.reverse()

        for key in software_keys:
            software_dict[key] = software_versions

    return software_dict

def query_database(software_dict: dict) -> list:
    if not software_dict:
        return []
    
    found_packages = []
    results = []

    for package in software_dict.keys():
        base_version = software_dict[package][0]
        for version in software_dict[package]:
            if package in found_packages:
                break

            url = ''
            if remote_url:
                url = remote_url.replace('<package>', package).replace('<version>', version)
            else:
                url = f'http://localhost:5000/api/search-product/{package}/{version}'

            try:
                print(url)
                response = requests.get(url)

                if response.status_code != 200:
                    continue

                response_json = response.json()

                if not response_json:
                    print('Empty response')
                    continue

                if len(response_json['version']) == 0:
                    continue

                response_json['base_version'] = [base_version]
                if verbose:
                    response_json['queried_version'] = [version]
                print(response_json)

                found_packages.append(package)

                results.append(response_json)

            except HTTPError as http_err:
                print(f'HTTP Error: f{http_err}')
                exit(1)
            except ConnectionError as conn_err:
                print(f'Connection Error: {conn_err}')
                exit(1)
    
    return results

def generate_report(query_results: list) -> None:
    with open('report.csv', 'w') as report:
        if verbose:
            report.write('product,base version,queried version,vulnerable version(s),summaries\n')
            report.writelines([f'{result["product"]},{result["base_version"]},{result["queried_version"]},{result["version"]},"{result["summaries"]}"\n' for result in query_results])
        else:
            report.write('product,base version,vulnerable version(s),summaries\n')
            report.writelines([f'{result["product"]},{result["base_version"]},{result["version"]},"{result["summaries"]}"\n' for result in query_results])



if __name__ == '__main__':
    main()