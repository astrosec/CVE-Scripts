import argparse
import platform
import importlib
import pkgutil
import re
from urllib.error import HTTPError
import urllib.request
import subprocess
import sys
import json
import time

parser = argparse.ArgumentParser(description='Generate a report of known software vulnerabilities on this system.')
parser.add_argument('-p', '--package', nargs=2, help='Queries the database for the specified package/version pair.')
parser.add_argument('-ap', '--allPackages', action='store_true', help='Queries the database for all packages installed on the system the script is running on.')
parser.add_argument('-f', '--file', help='Queries the database for a series of package/version pairs supplied in the specified file. The format for said file must be <package> <version> with each separated by a new line. The hostname and ip address of the origin of the software can be optionally included at the end of the line.')
parser.add_argument('-nm', '--nmap', action='store_true', help='Indicates the file passed in is an nmap XML file. The ideal command to generate this file would be "nmap -sV <network/range> -oX <output file>"')
parser.add_argument('-r', '--remote', help='Sets the database url for queries to the specified url. This flag must be paired with another one to perform a query. The format for the URL must contain the <package> and <version> tokens.', default='http://localhost:5000/api/search-product/<package>/<version>')
parser.add_argument('-v', '--verbose', action='store_true', help='Will expand the reporting done by breaking down the package version into parts to query for. This will potentially list more vulnerabilities due to a much broader search, but the results might not be applicable to the actual installed software.')
parser.add_argument('-o', '--output-dir', help='Specifies the relative output directory for the reports.', default='./')

modules = {
    importlib.import_module(f'plugins.{name}')
    for _, name, _
    in pkgutil.iter_modules(['plugins'])
}

def main() -> None:
    parse_args()

    software_list = []

    if package:
        software_list.append((package[0], package[1], "From CMD", "local"))
    
    if file_path:
        software_list.extend(get_software_from_file(file_path))

    if all_packages:
        determine_os()
        install_module_packages()
        software_list.extend(get_all_software_from_sys())
    
    filter_list(software_list)
    software_dict = parse_package_version_pairs(software_list)
    query_results = query_database(software_dict)

    generate_report(query_results)


def determine_os() -> None:
    """
    Determines the OS and distro (if Linux) and searches through the supplied modules
    for supported ones.
    If there are no supported modules, it will print an error and exit.
    If there are more than one supported module, it will offer a selection.
    """

    global os_module

    def match(supported_os_str: str, os_info: str) -> bool:
        if supported_os_str == os_info:
            return True
        
        supported_os_split = supported_os_str.split(':')
        os_info_split = os_info.split(':')
        for i in range(0, len(supported_os_split)):
            if supported_os_split[i] != '*' or supported_os_split[i] != os_info_split[i]:
                return False

        return True

    os_type = platform.system()

    if len(os_type) == 0:
        print('Error: Could not determine the system OS!')
        exit(1)

    if os_type == 'Linux':
        import distro
        os_distro = distro.id()
        if len(os_distro) == 0:
            print('Error: Could not determine Linux distro!')
            exit(1)
        os_type += f':{os_distro}'
    else:
        os_type += ':*'

    supported_modules = []
    
    for module in modules:
        for supported_os_str in module.get_supported_os():
            if match(supported_os_str, os_type):
                supported_modules.append(module)
                print(f'Sucessfully matched OS with supported module: {module}')
    
    if not len(supported_modules):
        print(f'Error: No module found for this OS! Supplied OS: {os_type}')
        print(platform.system())
        exit(1)

    if len(supported_modules) == 1:
        os_module = supported_modules[0]
        return
    
    print('Multiple supported modules found, please select the module to use: ')
    for i in range(len(supported_modules)):
        print(f'[{i}] {supported_modules[i]}')

    answer = input()
    while not answer.isdigit() or int(answer) < 0 or int(answer) >= len(supported_modules):
        print(f'Please enter a valid selection: 0-{len(supported_modules) - 1}: ')
        answer = input()

    os_module = supported_modules[int(answer)]

def install_module_packages() -> None:
    """
    Checks if the selected os module requires external python packages and if so, prompts
    the user, letting them know the modules it wishes to install.
    If 'Y' is chosen, it will attempt to automatically install the packages.
    If 'N' is chosen, it will abort the program. 
    """

    pip_packages = list(os_module.get_required_packages())

    for i in range(len(pip_packages) - 1, -1, -1):
        for sys_package in sys.modules.keys():
            if pip_packages[i] in sys_package:
                pip_packages.remove(pip_packages[i])
                break
    
    if not len(pip_packages):
        return
    
    print('The selected OS module requires the following python packages to run: ', end='')
    for pip_package in pip_packages:
        print(pip_package, end=' ')
    
    print('\nDo you wish to automatically install and proceed? (Y/n) ', end='')
    answer = input().upper()
    while answer != 'Y' and answer != 'N':
        print('Please enter a valid selection: Y/n:', end=' ')
        answer = input().upper()
    
    if answer == 'Y':
        for pip_package in pip_packages:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', pip_package])
                print(f'{pip_package} successfully installed.')
            except subprocess.CalledProcessError as e:
                print(f'Unable to install pip package: {pip_package}.\n{e}')
                exit(1)
            
    else:
        print('Aborting...')
        exit(0)

    time.sleep(2) # pause to allow the system to 'set in' the newly installed pip packages

def parse_args():
    """
    Parses the given commandline arguments.
    """

    global all_packages, package, file_path, remote_url, output_dir, nmap_xml, verbose

    args = parser.parse_args()
    if len(sys.argv)==1:
        parser.print_help(sys.stderr)
        exit(0)
    
    all_packages = args.allPackages
    package = tuple(args.package) if args.package else None
    file_path = args.file
    remote_url = args.remote
    verbose = args.verbose
    output_dir = args.output_dir
    nmap_xml = args.nmap

    if nmap_xml and not file_path:
        print('nmap flag provided without a given filepath. Please provide a filepath with the -f flag. See cveq.py -h for more information.')
        exit(1)

    if remote_url and ('<package>' not in remote_url or '<version>' not in remote_url):
        print('Remote url string is not formatted correctly!')
        exit(1)

def get_software_from_file(path: str, scan = False) -> list:
    """
    Reads the file at the given path and returns the software/version parts.
    """

    software = []

    if nmap_xml:
        import xml.etree.ElementTree as ET
        tree = ET.parse(path)
        root = tree.getroot()

        for host in root.findall('host'):
            hostname_s = host.find('./hostnames/hostname')
            #print(hostname_s)
            hostname = 'None' if hostname_s is None else hostname_s.get('name')
            ipaddr = host.find('address').get('addr')
            for port in host.find('ports').findall('port'):
                service = port.find('service')
                product = service.get('product')
                version = service.get('version')
                portid = port.get('portid')
                if not version or not product:
                    continue

                product = product.replace(' ', '.*').lower()
                version = version.replace(' ', '.*').lower()

                software.append((product, version, hostname, ipaddr + ':' + portid))
                
    else:
        with open(path, 'r') as software_file:
            for line in software_file.readlines():
                split = line.strip().split(' ')

                package = split[0]
                version = split[1]
                hostname = "From file"
                ipaddr = "N/A"

                if len(split) > 2:
                    hostname = split[2]
                    if len(split) == 4:
                        ipaddr = split[3]

                software.append((package, version, hostname, ipaddr))

    return software

def get_all_software_from_sys() -> list:
    """
    Returns the list of system software supplied from the os module using a new process to allow use 
    of newly installed pip packages.
    """

    process_result = subprocess.run([sys.executable, 'software_collector.py', os_module.__name__], check=True)
    return get_software_from_file('software.txt', True)

def break_package_string(string: str) -> list:
    """
    Breaks apart a package or version string into components by separator characters.
    """

    if not string:
        return []
    
    string_list = []
    built_string = ''

    search_list = re.findall(r'[_+\-~]?(?:[0-9\.*:]+|[a-zA-Z]+)', string)
    for item in search_list:
        built_string += item
        string_list.insert(0, built_string)

    return string_list

def filter_list(software_list: list):
    pattern = re.compile(r"[^ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\-._~:?#\[\]@!$&'()*+,;=]")
    for i in range(len(software_list) - 1, -1, -1):
        package, version, hostname, ipaddr = software_list[i]

        if package == "" or version == "":
            software_list.remove(software_list[i])
            print(f"Warning, pair {software_list[i]} has an empty package or version! Removing...")
            continue

        package = re.sub(pattern, ".*", package)
        version = re.sub(pattern, ".*", version)

        software_list[i] = (package, version, hostname, ipaddr)
        
def parse_package_version_pairs(software_list: list) -> list[tuple[dict, str, str]]:
    new_list = []

    for package, version, hostname, ipaddr in software_list:
        broken_package = break_package_string(package) if verbose else [package]
        broken_version = break_package_string(version) if verbose else [version]

        for part in broken_package:
            new_list.append(({part: broken_version}, hostname, ipaddr))

    return new_list

def query_database(software_list: list) -> list:
    if not software_list:
        return []
    
    results = []

    for package_dict, hostname, ipaddr in software_list:
        base_package = list(package_dict.keys())[0]
        base_version = package_dict[base_package][0]

        found = False

        for key in package_dict.keys():
            if found:
                break

            for version in package_dict[key]:
                url = remote_url.replace('<package>', key).replace('<version>', version)

                try:
                    print(f'Querying {url}')
                    req = urllib.request.Request(url=url, headers={'accept': 'application/json'})
                    response = urllib.request.urlopen(req)

                    if response.status != 200:
                        continue

                    response_json = json.loads(response.read())

                    if not response_json:
                        continue

                    if len(response_json['results']) == 0:
                        continue

                    for result in response_json["results"]:
                        result["host"] = hostname
                        result["ipaddr"] = ipaddr

                        if verbose:
                            result["base package"] = base_package
                            result["base version"] = base_version

                    results.extend(response_json['results'])
                    found = True
                    break

                except HTTPError as http_err:
                    print(f'HTTP Error: {http_err}')
                    exit(1)
                except ConnectionError as conn_err:
                    print(f'Connection Error: {conn_err}')
                    exit(1)

    return results

def generate_report(query_results: list) -> None:
    """
    Writes a report file (csv) with the results of the query.
    """

    header = 'CVE,assigner,published,last modified,summary,cvss3,impactScore3,exploitabilityScore3,vendors,products,vulnerable configurations,host,ipaddr' + (',base product,base version' if verbose else '') + '\n'

    with open(output_dir + 'report.csv', 'w') as report:
        report.write(header)

        for result in query_results:
            result["summary"] = result["summary"].replace('"', "'").replace('\n', ' ').strip()
            line = f'{result["id"]},{result["assigner"]},{result["published"]},{result["lastModified"]},"{result["summary"]}",{result["cvss3"]},{result["impactScore3"]},{result["exploitabilityScore3"]},"{result["vendors"]}","{result["products"]}","{result["vulnerable_configuration"]}",{result["host"]},{result["ipaddr"]}' + (f',{result["base package"]},{result["base version"]}' if verbose else '') + '\n'
            report.write(line)
        
if __name__ == '__main__':
    main()
