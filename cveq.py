import argparse
import platform
import importlib
import pkgutil
import re
from urllib.error import HTTPError
import urllib.request
import subprocess
import sys
import json
import time

parser = argparse.ArgumentParser(description='Generate a report of known software vulnerabilities on this system.')
parser.add_argument('-p', '--package', nargs=2, help='Queries the database for the specified package/version pair.')
parser.add_argument('-ap', '--allPackages', action='store_true', help='Queries the database for all packages installed on the system the script is running on.')
parser.add_argument('-f', '--file', help='Queries the database for a series of package/version pairs supplied in the specified file. The format for said file must be <package> <version> with each separated by a new line.')
parser.add_argument('-r', '--remote', help='Sets the database url for queries to the specified url. This flag must be paired with another one to perform a query. The format for the URL must contain the <package> and <version> tokens.')
parser.add_argument('-v', '--verbose', action='store_true', help='Will expand the reporting done by breaking down the package version into parts to query for. This will potentially list more vulnerabilities due to a much broader search, but the results might not be applicable to the actual installed software.')

modules = {
    importlib.import_module(f'plugins.{name}')
    for finder, name, ispkg
    in pkgutil.iter_modules(['plugins'])
}

def main() -> None:
    parse_args()

    software_list = []
    if package:
        software_list.append((package[0], package[1]))
    
    if file_path:
        software_list.extend(get_software_from_file(file_path))

    if all_packages:
        determine_os()
        install_module_packages()
        software_list.extend(get_all_software_from_sys())
    
    software_dict = parse_package_version_pairs(software_list)
    #print(software_dict)
    query_results = query_database(software_dict)
    generate_report(query_results)


def determine_os() -> None:
    """
    Determines the OS and distro (if Linux) and searches through the supplied modules
    for supported ones.
    If there are no supported modules, it will print an error and exit.
    If there are more than one supported module, it will offer a selection.
    """

    global os_module

    def match(supported_os_str: str, os_info: str) -> bool:
        if supported_os_str == os_info:
            return True
        
        supported_os_split = supported_os_str.split(':')
        os_info_split = os_info.split(':')
        for i in range(0, len(supported_os_split)):
            if supported_os_split[i] != '*' or supported_os_split[i] != os_info_split[i]:
                return False

        return True

    os_type = platform.system()

    if len(os_type) == 0:
        print('Error: Could not determine the system OS!')
        exit(1)

    if os_type == 'Linux':
        import distro
        os_distro = distro.id()
        if len(os_distro) == 0:
            print('Error: Could not determine Linux distro!')
            exit(1)
        os_type += f':{os_distro}'
    else:
        os_type += ':*'

    supported_modules = []
    
    for module in modules:
        for supported_os_str in module.get_supported_os():
            if match(supported_os_str, os_type):
                supported_modules.append(module)
                print(f'Sucessfully matched OS with supported module: {module}')
    
    if not len(supported_modules):
        print(f'Error: No module found for this OS! Supplied OS: {os_type}')
        print(platform.system())
        exit(1)

    if len(supported_modules) == 1:
        os_module = supported_modules[0]
        return
    
    print('Multiple supported modules found, please select the module to use: ')
    for i in range(len(supported_modules)):
        print(f'[{i}] {supported_modules[i]}')

    answer = input()
    while not answer.isdigit() or int(answer) < 0 or int(answer) >= len(supported_modules):
        print(f'Please enter a valid selection: 0-{len(supported_modules) - 1}: ')
        answer = input()

    os_module = supported_modules[int(answer)]

def install_module_packages() -> None:
    """
    Checks if the selected os module requires external python packages and if so, prompts
    the user, letting them know the modules it wishes to install.
    If 'Y' is chosen, it will attempt to automatically install the packages.
    If 'N' is chosen, it will abort the program. 
    """

    pip_packages = list(os_module.get_required_packages())

    for i in range(len(pip_packages) - 1, -1, -1):
        for sys_package in sys.modules.keys():
            if pip_packages[i] in sys_package:
                pip_packages.remove(pip_packages[i])
                break
    
    if not len(pip_packages):
        return
    
    print('The selected OS module requires the following python packages to run: ', end='')
    for pip_package in pip_packages:
        print(pip_package, end=' ')
    print('\nDo you wish to automatically install and proceed? (Y/n) ', end='')
    answer = input().upper()
    while answer != 'Y' and answer != 'N':
        print('Please enter a valid selection: Y/n:', end=' ')
        answer = input().upper()
    
    match answer:
        case 'Y':
            for pip_package in pip_packages:
                try:
                    subprocess.check_call([sys.executable, '-m', 'pip', 'install', pip_package])
                    print(f'{pip_package} successfully installed.')
                except subprocess.CalledProcessError as e:
                    print(f'Unable to install pip package: {pip_package}.\n{e}')
                    exit(1)
        case 'N':
            print('Aborting...')
            exit(0)

    time.sleep(2)

def parse_args():
    """
    Parses the given commandline arguments.
    """

    global all_packages, package, verbose, file_path, remote_url

    args = parser.parse_args()
    if len(sys.argv)==1:
        parser.print_help(sys.stderr)
        exit(0)
    all_packages = args.allPackages
    package = tuple(args.package) if args.package else None
    file_path = args.file
    remote_url = args.remote
    verbose = args.verbose

    if remote_url and ('<package>' not in remote_url or '<version>' not in remote_url):
        print('Remote url string is not formatted correctly!')
        exit(1)

def get_software_from_file(path: str) -> list:
    """
    Reads the file at the given path and returns the software/version parts.
    """

    software = []

    with open(path, 'r') as software_file:
        software = [tuple(line.replace('\n', '').split(' ')) for line in software_file.readlines()]

    return software

def get_all_software_from_sys() -> list:
    """
    Returns the list of system software supplied from the os module using a new process to allow use 
    of newly installed pip packages.
    """

    process_result = subprocess.run([sys.executable, 'software_collector.py', os_module.__name__], check=True)
    return get_software_from_file('software.txt')

def break_package_string(string: str) -> list:
    """
    Breaks apart a package or version string into components by separator characters.
    """

    if not string:
        return []
    
    string_list = []
    built_string = ''

    search_list = re.findall(r'[_+\-~]?(?:[0-9\.:]+|[a-zA-Z]+)', string)
    for item in search_list:
        built_string += item
        string_list.append(built_string)

    return string_list

def parse_package_version_pairs(software_list: list) -> dict:
    """
    Parses the software list into a dictionary of package keys and version lists for varying queries.
    """

    software_keys = []
    software_versions = []
    software_dict = {}

    for entry in software_list:
        software_keys = break_package_string(entry[0])
        version = entry[1]
        software_versions = break_package_string(version) if verbose else [version]
        software_keys.reverse()
        software_versions.reverse()

        for key in software_keys:
            software_dict[key] = software_versions

    return software_dict

def query_database(software_dict: dict) -> list:
    """
    Queries the database with the supplied dictionary and returns a dictionary of the package,
    queried version (if verbose), base version, 
    """

    if not software_dict:
        return []
    
    found_packages = []
    results = []

    for package in software_dict.keys():
        base_version = software_dict[package][0]
        for version in software_dict[package]:
            if package in found_packages:
                break

            url = ''
            if remote_url:
                url = remote_url.replace('<package>', package).replace('<version>', version)
            else:
                url = f'http://localhost:5000/api/search-product/{package}/{version}'

            try:
                print(f'Querying {url}')
                req = urllib.request.Request(url=url, headers={'accept': 'application/json'})
                response = urllib.request.urlopen(req)

                if response.status != 200:
                    continue

                response_json = eval(response.read())

                if not response_json:
                    continue

                if len(response_json['version']) == 0:
                    continue

                response_json['base_version'] = [base_version]
                if verbose:
                    response_json['queried_version'] = [version]
                #print(response_json)

                found_packages.append(package)

                results.append(response_json)

            except HTTPError as http_err:
                print(f'HTTP Error: {http_err}')
                exit(1)
            except ConnectionError as conn_err:
                print(f'Connection Error: {conn_err}')
                exit(1)
    
    return results

def generate_report(query_results: list) -> None:
    """
    Writes a report file (csv) with the results of the query.
    """

    results = [f'{result["product"]},{result["base_version"]},"{result["version"]}","{result["summaries"]}"\n' for result in summary_filtered_results]
    verbose_results = [f'{result["product"]},{result["base_version"]},{result["queried_version"]},"{result["version"]}","{result["summaries"]}"\n' for result in query_results]
    summary_filtered_verbose_results = [f'{result["product"]},{result["base_version"]},{result["queried_version"]},"{result["version"]}","{result["summaries"]}"\n' for result in query_results if len(result["summaries"]) > 0]
    summary_filtered_results = [f'{result["product"]},{result["base_version"]},"{result["version"]}","{result["summaries"]}"\n' for result in summary_filtered_results if len(result["summaries"]) > 0]
    verbose_header = 'product,"base version","queried version","vulnerable version(s)",summaries\n'
    nonverbose_header = 'product,"base version","vulnerable version(s)",summaries\n'

    with open('report.csv', 'w') as report:
        if verbose:
            report.write(verbose_header)
            report.writelines(summary_filtered_verbose_results)
        else:
            report.write(nonverbose_header)
            report.writelines(summary_filtered_results)
        print(f'Wrote {len(summary_filtered_results)} results to {report.name}.')

    with open('report-verbose.csv', 'w') as report:
        if verbose:
            report.write(verbose_header)
            report.writelines(verbose_results)
        else:
            report.write(nonverbose_header)
            report.writelines(results)
        print(f'Wrote {len(query_results)} results to {report.name}.')
        
if __name__ == '__main__':
    main()
