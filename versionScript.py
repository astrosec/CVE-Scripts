import csv
import requests
from urllib.error import HTTPError
import csv
import argparse
import subprocess
import re

parser = argparse.ArgumentParser(description='Generate a report of known software vulnerabilities on this system.')
parser.add_argument('-p', '--package', nargs=2, help='Queries the database for the specified package/version pair.')
parser.add_argument('-ap', '--allPackages', action='store_true', help='Queries the database for all packages installed on the system the script is running on.')
parser.add_argument('-f', '--file', help='Queries the database for a series of package/version pairs supplied in the specified file. The format for said file must be <package> <version> with each separated by a new line.')
parser.add_argument('-r', '--remote', help='Sets the database url for queries to the specified url. This flag must be paired with another one to perform a query.')
parser.add_argument('-v', '--verbose', action='store_true', help='Will expand the reporting done by including all hits from the same package with different version expansions. This could possibly list more vulnerabilites, but will often result in multiple equivilant entries.')
args = parser.parse_args()
print(args)

ap = args.allPackages
pack = None
version = None
if args.package:
    pack = args.package[0]
    version = args.package[1]
filePath = args.file
remote_url = args.remote
verbose = args.verbose

softwareList = []
softwareVersionDict = {}

if ap:
    cmd = 'apt list --installed | tail -n +2'
    processResult = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
    #with open('package.csv', 'w') as f:
    #      f.write(processResult.stdout)
    softwareList = processResult.stdout.split('\n')[:-1]

def breakByDash(string):
    if not string:
        return []
    
    string_list = []
    built_string = ''

    search_list = re.findall(r'[_+\-~]?(?:[0-9\.:]+|[a-zA-Z]+)', string)
    for item in search_list:
        built_string += item
        string_list.append(built_string)

    return string_list

if pack:
    softwareList.append(f'{pack} {version} ')

if filePath:
    try:
        f = open(filePath, 'r')
        softwareList.extend(f.readlines())
        f.close()
    except IOError:
        print('IOError: No such file or directory!')
        exit(1)

if remote_url and ('<package>' not in remote_url or '<version>' not in remote_url):
    print('Remote url string is not formatted correctly!')
    exit(1)


for line in softwareList:
    if len(line) == 0:
        continue

    softwarePattern = re.search(r'^[a-zA-Z\-\.0-9+_~]+[/ ]', line)
    versionPattern = re.search(r' \d+[^\s]*\s', line)

    if not softwarePattern:
        print(f'Error: Error parsing software package! Skipping: {line}')
        continue
    if not versionPattern:
        print(f'Error: Error parsing software version! Skipping: {line}')
        continue

    software_keys = breakByDash(softwarePattern.group()[:-1])
    software_versions = breakByDash(versionPattern.group().strip())

    for key in software_keys:
        softwareVersionDict[key] = software_versions




#print(softwareVersionDict)

with open('report.csv', 'w') as csvFile:
    writer = csv.DictWriter(csvFile, fieldnames=['product', 'version', 'summaries'])
    writer.writeheader()
    found_packages = []

    for package in softwareVersionDict.keys():

        for version_part in softwareVersionDict[package]:
            if not verbose and package in found_packages:
                break
            
            url = ''
            if remote_url:
                url = remote_url.replace('<package>', package).replace('<version>', version)
            else:
                url = f'http://localhost:5000/api/search-product/{package}/{version_part}'
    
            try:
                print(url)
                response = requests.get(url)
            
                if(response.status_code == 200):
                    responseJsonDict = response.json()
                    if responseJsonDict:
                        if len(responseJsonDict['version']) == 0:
                            continue

                        print(responseJsonDict)
                        writer.writerow(responseJsonDict)

                        if not verbose: 
                            found_packages.append(package)
                    else:
                        print("Empty response")

            except HTTPError as http_err:
                print("HTTP error: %s" % (http_err))
                exit(1)
            except ConnectionError as conn_err:
                print("Connection error: %s" % (conn_err))
                exit(1)

    csvFile.close()


