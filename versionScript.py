import csv
import requests
from urllib.error import HTTPError
import csv
import argparse
import subprocess
import re

parser = argparse.ArgumentParser(description='Generate a report of known software vulnerabilities on this system.')
parser.add_argument('-p', '--package', nargs=2)
parser.add_argument('-ap', '--allPackages', action='store_true')
parser.add_argument('-f', '--file')
parser.add_argument('-r', '--remote')
args = parser.parse_args()
print(args)

ap = args.allPackages
pack = None
version = None
if args.package:
    pack = args.package[0]
    version = args.package[1]
filePath = args.file
remote_url = args.remote

softwareList = []
softwareVersionDict = {}

softwareTagBlacklist = [
     '-stable',
     '-common',
     '-dev'
]

if ap:
    cmd = 'apt list --installed | tail -n +2'
    processResult = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
    #with open('package.csv', 'w') as f:
    #      f.write(processResult.stdout)
    softwareList = processResult.stdout.split('\n')[:-1]

def breakByDash(string):
    if not string:
        return []
    
    string_list = []
    built_string = re.match(r'^[^-~+_]+', string).group()
    string_list.append(built_string)

    search_list = re.findall(r'[-~+_][0-9a-zA-Z\.]+', string)
    for item in search_list:
        built_string += item
        string_list.append(built_string)

    return string_list

if pack:
    softwareList.append(f'{pack} {version} ')

if filePath:
    try:
        f = open(filePath, 'r')
        softwareList.extend(f.readlines())
        f.close()
    except IOError:
        print('IOError: No such file or directory!')
        exit(1)

if remote_url and ('<package>' not in remote_url or '<version>' not in remote_url):
    print('Remote url string is not formatted correctly!')
    exit(1)


for line in softwareList:
    if len(line) == 0:
        continue

    softwarePattern = re.search(r'^[a-zA-Z\-\.0-9+_~]+[/ ]', line)
    versionPattern = re.search(r' \d+[^\s]*\s', line)

    if not softwarePattern:
        print(f'Error: Error parsing software package! Skipping: {line}')
        continue
    if not versionPattern:
        print(f'Error: Error parsing software version! Skipping: {line}')
        continue

    software_keys = breakByDash(softwarePattern.group()[:-1])
    software_versions = breakByDash(versionPattern.group().strip())

    for key in software_keys:
        softwareVersionDict[key] = software_versions




#print(softwareVersionDict)

with open('report.csv', 'w') as csvFile:
    writer = csv.DictWriter(csvFile, fieldnames=['product', 'version', 'summaries'])
    writer.writeheader()
    for package in softwareVersionDict.keys():
        for version_part in softwareVersionDict[package]:
            url = ''
            if remote_url:
                url = remote_url.replace('<package>', package).replace('<version>', version)
            else:
                url = f'http://localhost:5000/api/search-product/{package}/{version_part}'
    
            try:
                print(url)
                response = requests.get(url)
            
                if(response.status_code == 200):
                    responseJsonDict = response.json()
                    if responseJsonDict:
                        if len(responseJsonDict['version']) == 0:
                            continue
                        print(responseJsonDict)
                        writer.writerow(responseJsonDict)
                    else:
                        print("Empty response")
            except HTTPError as http_err:
                print("HTTP error: %s" % (http_err))
                exit(1)
            except ConnectionError as conn_err:
                print("Connection error: %s" % (conn_err))
                exit(1)

    csvFile.close()


